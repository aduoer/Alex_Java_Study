# day11

##  接口

### 语法

- 相当于特殊的抽象类
- 用interface关键字定义接口
- 没有构造方法，不能创建对象
- 只能包含公开的静态常量（可以省略public static final），公开的抽象方法（可以省略public abstract）

- implements实现接口，声明引用调用

### 接口与抽象类的区别

#### 相同

- 可编译成字节码文件
- 不能创建对象
- 都可以声明变量（引用）
- 隐式具备Object类中所定义的方法

#### 不同

- 接口所有属性都是公开静态常量，隐式使用public static final修饰
- 接口所有方法都是公开抽象方法，隐式使用public abstract修饰
- 接口没有构造方法、动态代码块、静态代码块
- 抽象类没有限制

### 微观概念

- 接口是一种能力和约定

- 接口的定义：代表了某种能力

- 方法的定义：能力的具体要求

- 经验：Java为单继承，当父类的方法种类无法满足子类需求时，可实现接口扩充子类能力

  如果一个类既要继承父类，也要实现接口，继承在前，实现在后

  ```java
  public class dog extends Animal implements Runable{
  
  }
  ```

- 接口支持多实现，可为类扩充多种能力

#### 使用规范

任何类在实现接口时，必须实现接口中所有的抽象方法，否则此类为抽象类。

同父类一样，接口可声明为引用，并指向实现类对象

仅可调用接口中所声明的方法，不可调用实现类中独有的方法

可强转回实现类本身类型，进行独有方法调用

#### 常见关系

##### 类与类：

- 单继承
- extends 父类名称

##### 类与接口：

- 多实现
- implements 接口名称1 , 接口名称2 , 接口名称n
- 继承和实现同时存在时，继承在前，实现在后。

##### 接口与接口：

- 多继承
- extends 父接口1 , 父接口2 , 父接口n

#### 常量接口：

将多个常用于表示状态或固定值的变量，以静态常量的形式定义在接口中统一管理，提高代码可读性。

#### 标记接口

接口没有任何成员,仅仅是一个标记。Serializable、Cloneable

### 宏观概念

接口是一种标准

#### 接口回调

接口的使用类调用，而不是实现类直接调用

### 接口的好处

- 降低代码的耦合性，更自然的实现多态
- 设计与实现完全分离、更容易搭建程序框架、更换具体实现

#### JDK1.8接口变化

- JDK1.8版本接口中可以包含静态方法和默认方法
- 静态方法：不能被继承，通过接口名.方法名调用
- 默认方法：可以被继承，也可以被重写，通过实现类对象调用

#### JDK1.9接口变化

- JDK1.9版本之后接口中可以包含私有方法
- 只能再默认方法中调用，为接口自己服务

### 面向对象的设计原则

##### 总则：开闭原则（Open Close Principle，OCP）

​	开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。

##### 单一职责原则（Single Responsibility Principle，SRP）

​	不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。

##### 里氏替换原则（Liskov Substitution Principle，LSP）

​	里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。

​	里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。

##### 依赖倒置原则（Dependence Inversion Principle，DIP）

​	面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。

##### 接口隔离原则（Interface Segregation Principle，ISP）

​	每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。

##### 迪米特法则（最少知道原则）（Demeter Principle，DP）

​	一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。

​	只和朋友通信，不和陌生人说话。

##### 合成/聚合复用原则（Composite Reuse Principle，CRP）

​	原则是尽量首先使用合成/聚合的方式，而不是使用继承。

##### 设计原则的目的：

​	降低代码之间的耦合性，增强程序的可复用性、可扩展性和可维护性。

​	高内聚低耦合是衡量软件设计好坏的标准和依据。

#### 口诀：开口里合最单依

### 类之间的关系

泛化（继承）——>实现（接口）——>组合——>聚合——>关联——>依赖 

## 常用类

### 内部类

#### 概念

​	在一个类的内部再定义一个完整的类，内层的类称为内部类

#### 特点

- 编译之后可生成独立的字节码文件
- 内部类可以访问外部类的私有成员，而不破坏封装
- 可为外部类提供必要的功能

### 分类

- ##### 成员内部类

  ​	在类的内部定义，与实例变量、实例方法同级别的类

  ​	外部类的一个实例部分，创建内部类对象时，必须依赖外部类对象

  ​	Outer out = new Outer();

  ​	Outer.Inner in = out.new Inner();

  特点：

  - 成员内部类可以使用任意访问修饰符。

  - 成员内部类可以直接访问外部类的属性和方法。

  - 成员内部类中属性和外部类的属性同名时，使用“外部类名.this”访问外部类的属性

  - 成员内部类不能包含静态成员，但是可以包含静态常量,JDK16之后可以包含静态成员

- 静态内部类

  ​	不依赖外部类对象，可直接创建或通过类名访问，相当于外部类，为外部类提供功能 

  ​	不创建外部类对象，直接创建内部类对象

  ​	Outer.Inner inner = new Outer.Inner();

  ​	inner.show(); 

  特点：

  - 静态内部类可以使用任意访问修饰符

  - 静态内部类不能直接访问外部类的实例属性和方法，可以直接访问静态的属性和方法

  - 静态内部类可以包含静态成员

- 局部内部类

  ​	定义在外部类方法中，创建对象范围仅限于当前方法，限制类的使用范围。

  特点: 

  - 不能使用任何访问修饰符。

  - 如果局部内部类所在方法是实例方法，可以直接访问外部类的实例属性和方法；如果局部内部类所在方法是静态方法，只能访问外部类的静态属性和方法。

  - 局部内部类可以访问局部变量，但是局部变量必须是final,JDK1.8 final可以省略,因为对象生命周期长于局部变量。

  - 局部内部类也不能声明静态成员, 可以使用静态常量，JDK16之后可以包含静态成员

- 匿名内部类

  ​	相当于没有类名的局部内部类，必须继承父类或者实现接口。 

  ​	定义类、创建对象的语法合并，只能创建一个该类的对象。

  ​	优点：减少代码量。缺点：可读性较差。 

  特点:

  - 创建匿名内部类可以使用接口，抽象类，普通类，必须实现接口或抽象类中抽象方法。

  - 匿名内部类不能手动添加构造方法, 不能包含静态成员。

  - 匿名内部类中一般不包含特有的属性和方法，不能直接访问，可以通过可访问方法调用或匿名对象调用。

  - 匿名内部类生成的class文件名：外部类名$编号.class
